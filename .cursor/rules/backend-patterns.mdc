---
title: Backend Development Patterns
---

# Backend Development Patterns

## FastAPI Structure

### Router Organization
- Use `APIRouter` for modular endpoint organization
- Group related endpoints under common prefixes
- Implement proper dependency injection
- Use tags for API documentation

### Example Router Structure
```python
from fastapi import APIRouter, Depends, HTTPException, status

router = APIRouter(tags=["Module Name"])

@router.get("/")
async def get_items(current_user: dict = Depends(get_current_user)):
    # Implementation
```

## Authentication & Authorization

### Dependencies Pattern
- [backend/auth/dependencies.py](mdc:backend/auth/dependencies.py) - Centralized authentication
- User ID conversion from MongoDB ObjectId to string
- Active user validation
- Token expiration checking

### Role-Based Access
- [backend/auth/ceo_auth.py](mdc:backend/auth/ceo_auth.py) - CEO-only operations
- [backend/auth/delivery_challan_auth.py](mdc:backend/auth/delivery_challan_auth.py) - Role-based access
- Implement proper error messages for unauthorized access

## CSRF Protection

### Implementation Pattern
- [backend/auth/csrf_utils.py](mdc:backend/auth/csrf_utils.py) - Token management
- User-specific tokens with expiration
- Reusable within session (not one-time use)
- Required for all state-changing operations

### Usage in Routes
```python
@router.post("/")
async def create_item(
    data: ItemCreate,
    current_user: dict = Depends(get_manager),
    x_csrf_token: str = Header(..., alias="X-CSRF-Token")
):
    require_csrf_token(x_csrf_token, current_user['id'])
    # Implementation
```

## Pydantic Models

### Model Structure
- Use `BaseModel` for all data models
- Implement proper validation with `@validator`
- Handle date conversions for MongoDB compatibility
- Use `model_dump()` instead of deprecated `.dict()`

### Date Handling
```python
from datetime import datetime, date
from pydantic import BaseModel, validator

class ItemModel(BaseModel):
    date_field: date
    
    @validator('date_field', pre=True)
    def validate_date(cls, v):
        if isinstance(v, str):
            try:
                return datetime.strptime(v, '%Y-%m-%d').date()
            except ValueError:
                raise ValueError('Invalid date format. Use YYYY-MM-DD')
        return v
```

## MongoDB Integration

### Database Connection
- [backend/database.py](mdc:backend/database.py) - Async MongoDB connection
- Use `motor` for async operations
- Implement proper connection pooling
- Handle connection errors gracefully

### Collection Operations
```python
from database import get_async_database
from bson import ObjectId

async def get_item(item_id: str):
    db = await get_async_database()
    collection = db.collection_name
    
    if not ObjectId.is_valid(item_id):
        raise HTTPException(status_code=400, detail="Invalid ID format")
    
    item = await collection.find_one({"_id": ObjectId(item_id)})
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    # Convert ObjectId to string
    item['id'] = str(item['_id'])
    del item['_id']
    return item
```

## Error Handling

### HTTP Exception Pattern
- Use specific HTTP status codes
- Provide clear error messages
- Implement proper exception hierarchy
- Handle both expected and unexpected errors

### Error Handling Structure
```python
try:
    # Main logic
    result = await some_operation()
    return result
except HTTPException:
    # Re-raise HTTP exceptions
    raise
except Exception as e:
    # Handle unexpected errors
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail=f"Operation failed: {str(e)}"
    )
```

## Date and Time Handling

### IST Timezone
- Use `pytz` for IST timezone handling
- Convert dates to datetime for MongoDB storage
- Implement proper date validation
- Handle timezone conversions consistently

### Date Utilities
```python
from datetime import datetime, date
import pytz

def get_ist_now():
    ist = pytz.timezone('Asia/Kolkata')
    return datetime.now(ist)

def validate_ist_date(date_obj):
    ist_now = get_ist_now().date()
    return date_obj <= ist_now
```

## File Upload Handling

### File Validation
- Validate file types and sizes
- Generate unique filenames
- Implement secure file storage
- Handle upload errors gracefully

### Upload Pattern
```python
import os
import uuid
from fastapi import UploadFile, File

UPLOAD_DIR = "uploads/module_name"
os.makedirs(UPLOAD_DIR, exist_ok=True)

@router.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    # Validate file type
    allowed_extensions = ['.pdf', '.jpg', '.png']
    file_extension = os.path.splitext(file.filename)[1].lower()
    
    if file_extension not in allowed_extensions:
        raise HTTPException(status_code=400, detail="File type not allowed")
    
    # Generate unique filename
    unique_filename = f"{uuid.uuid4()}{file_extension}"
    file_path = os.path.join(UPLOAD_DIR, unique_filename)
    
    # Save file
    with open(file_path, "wb") as buffer:
        content = await file.read()
        buffer.write(content)
    
    return {"file_path": file_path, "file_name": file.filename}
```

## Response Models

### Standard Response Format
- Use consistent response structure
- Include status, message, and data fields
- Implement proper pagination for lists
- Handle empty results gracefully

### Response Pattern
```python
from typing import List, Optional

class ListResponse(BaseModel):
    status: str
    message: str
    items: List[ItemModel]
    total: int

@router.get("/", response_model=ListResponse)
async def get_items(skip: int = 0, limit: int = 100):
    # Implementation
    return {
        "status": "success",
        "message": f"Retrieved {len(items)} items",
        "items": items,
        "total": total
    }
```

## Environment Configuration

### Configuration Management
- Use environment variables for configuration
- Implement proper default values
- Handle missing configuration gracefully
- Use type-safe configuration classes

### Configuration Pattern
```python
import os
from typing import Optional

class Config:
    SECRET_KEY: str = os.getenv("SECRET_KEY", "default-secret")
    DATABASE_URL: str = os.getenv("DATABASE_URL", "mongodb://localhost:27017")
    FRONTEND_URL: Optional[str] = os.getenv("FRONTEND_URL")
```
