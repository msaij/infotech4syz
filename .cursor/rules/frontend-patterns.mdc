---
name: Frontend Development Patterns
description:
globs:
alwaysApply: false
---

# Frontend Development Patterns

## Next.js App Router Structure

### Layout System
- [frontend/src/app/foursyz/layout.tsx](mdc:frontend/src/app/foursyz/layout.tsx) - Authentication and authorization wrapper
- Early `return null` for unauthorized users to prevent content flashing
- Role-based redirection logic
- Token validation and refresh handling

### Page Components
- Use TypeScript for type safety
- Implement proper error boundaries
- Handle loading states gracefully
- Use React hooks for state management

## Service Layer Pattern

### API Services
- [frontend/src/utils/deliveryChallanService.ts](mdc:frontend/src/utils/deliveryChallanService.ts) - Example service implementation
- Always fetch fresh CSRF tokens for state-changing operations
- Comprehensive error handling with specific messages
- TypeScript interfaces for API responses

### Service Structure
```typescript
class ServiceName {
  private baseUrl = `${env.BACKEND_URL}/endpoint`
  private csrfToken: string | null = null

  private async ensureCSRFToken(): Promise<string> {
    // Always fetch fresh token
  }

  private getHeaders(): HeadersInit {
    // Standard headers with auth
  }

  private getHeadersWithCSRF(): HeadersInit {
    // Headers with CSRF token
  }
}
```

## Error Handling Patterns

### Service Layer Errors
- Network error detection (`TypeError` with `fetch`)
- Specific error message extraction from API responses
- Fallback to status text if JSON parsing fails
- Clear error propagation to UI

### UI Error Handling
- Error state management with `useState`
- User-friendly error messages
- Retry mechanisms for failed operations
- Success message display with auto-hide

### Error Display Components
```typescript
{error && (
  <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
    <span className="block sm:inline">{error}</span>
    <button onClick={clearError}>Ã—</button>
    <button onClick={retryLoadData}>Retry</button>
  </div>
)}
```

## Form Handling

### Controlled Components
- Use `useState` for form data
- Implement proper validation
- Handle form submission with loading states
- Clear form after successful submission

### Date Handling
- Use `YYYY-MM-DD` format for input fields
- Convert to display format (DD/MM/YYYY) for UI
- Handle IST timezone requirements
- Validate dates are not in the future

## Styling Guidelines

### Tailwind CSS
- Use `text-black bg-white` for input fields to ensure visibility
- Consistent spacing with Tailwind utilities
- Responsive design patterns
- Dark mode considerations

### Component Styling
- Consistent button styling across components
- Proper form field spacing
- Modal and overlay styling
- Loading spinner implementations

## State Management

### Local State
- Use `useState` for component-specific state
- Implement proper state updates
- Handle async state updates correctly
- Clean up state on component unmount

### Global State
- Use localStorage for persistent data (tokens, user data)
- Implement proper token management
- Handle authentication state changes
- Role-based state management

## TypeScript Best Practices

### Interface Definitions
- Define interfaces for all API responses
- Use proper typing for form data
- Implement generic types where appropriate
- Export interfaces for reuse

### Type Safety
- Avoid `any` types where possible
- Use proper typing for async functions
- Implement proper error typing
- Use union types for constrained values

## Performance Considerations

### Code Splitting
- Use dynamic imports for large components
- Implement proper loading states
- Optimize bundle size
- Use React.memo for expensive components

### API Optimization
- Implement proper caching strategies
- Use pagination for large datasets
- Optimize API calls with debouncing
- Handle concurrent requests properly
